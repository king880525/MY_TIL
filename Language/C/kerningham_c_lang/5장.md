포인터: 다른 변수의 주소를 그 값으로 가지는 변수
ANSI C에서는 포인터 사용이 더 명확하게 되었고, 형을 고정하지 않는 일반 포인터 형태가 char\*에서 void\*로 변경되었다.

보통 배열은 메모리에 연속적으로 기록
포인터 변수 p는 변수 c가 기록된 메모리의 번지수를 값으로 저장한다.
p = &c;
&연산자는 메모리에 있는 대상(변수와 배열)에만 사용 가능하고 문자나 상수에서는 사용 불가능하다.
\* 연산자는 포인터가 가리키고 있는 변수의 값을 알려준다.
``` c
int x = 1, y = 2, z[10];
int *ip;

ip = &x; /* ip now points to x*/
y = *ip; /* y is now 1*/
*ip = 0; /* x is now 0*/
ip = &z[0]; /* ip now points to z[0]*/
```
포인터 선언
``` c
int *ip;
```

포인터와 매개변수
c에서 호출할 때, 매개변수는 그 값만 전달(call by value)하므로 호출된 함수에서 호출한 함수의 변수를 바꾸는 것은 불가능하다.
포인터를 매개변수로 사용하면 호출된 함수에서 호출한 함수의 변수를 주소로 접근하여 변경할 수 있다.

포인터와 배열
배열의 이름은 그 배열 첫번째 요소의 위치를 나타낸다.
``` c
pa = &a[0]; /* pa의 값은 a의 값과 동일하다.*/
```
a\[i]를 \*(a+i)와 같이 사용 가능하다.

배열이나 포인터를 매개변수로 전달하는 경우 아래와 같이 정의 가능하다.
``` c
f(int arr[]) { }
f(int* arr) { }
```

번지 연산
포인터, 배열, 번지계산이 통합되어 있다.
포인터와 정수형은 바꾸어 사용할 수 없다.
포인터에서 0은 사용할 수 있고, NULL로 대체해서 사용하기도 한다.
NULL은  stdio.h에 정의되어 있다.
포인터에 대한 정수를 더하거나 뺄 수 있다.
포인터를 0과 비교할 수도 있고, 같은 배열 내의 두 포인터를 비교할 수도 있다.
포인터에 포인터를 더하거나 뺄 수는 없고, 포인터에 실수를 더하거나 뻴 수 없다.
포인터에 곱셈이나 나눗셈을 할 수 없다.
포인터에 비트 연산도 불가능하다.
cast연산자 없이 어떤 형의 포인터를 다른 형의 포인터로 사용하면 안 된다.(void 예외)

문자 포인터와 함수
문자열은 항상 NULL문자 '\0'으로 끝나도록 되어 있다.
``` c
char amessage[] = "now is the time"; /* an array */
char* pmessage = "now is the time"; /* a pointer */
```
ameesage는 배열인데 끝에 '\0'이 있고 각각의 문자를 바꿀 수 있다.
pmessage는 포인터이므로 가리키는 위치를 바꿀 수 있지만, 내용을 바꾸는 것은 정의되어 있지 않다.

포인터 배열
포인터도 배열로 지정할 수 있다.

다차원 배열
c는 다차원 배열을 제공하지만, 포인터의 배열보다는 많이 사용하지 않는다.

포인터와 다차원 배열
``` c
int a[10][20];
int *b[10];
```
b가 a와 동일하게 20크기의 요소를 10개 가진다면 포인터 10개 + 요소 20\*10해서 210의 용량을 소모한다.
하지만 b는 배열의 각 요소들의 크기를 다르게 지정할 수 있다.

명령 라인 매개변수
c를 지원하는 환경(mx-dos, unix, linux 등)에서 어떤 프로그램이 실행을 시작할 때, 명령라인 매개변수를 프로그램에 넘겨주는 것이 가능하다.
main이 호출될 때, 두 개의 매개변수가 전달된다.
첫번째 것(argc)는 프로그램을 실행하기 위한 매개변수의 개수
두번째 것(argv)는 매개변수들의 모임인 문자열을 가리키기 위한 포인터
argv[0]은 프로그램 자신의 이름이다. 따라서 argc는 적어도 1이다.

함수의 포인터
c에서 함수는 변수가 아니지만 함수의 포인터를 정의할 수 있다.
함수의 포인터는 매개변수로 사용될 수 있고, 배열의 원소로 사용될 수도 있다.

dcl
선언문을 설명으로 바꾸어주는 함수 dcl
dcl은 c의 선언에 관한 문법을 그대로 적용한 프로그램이다.
