# Monday, July 25, 2022
# C언어 - stat
파일의 상태를 가져오는 함수
## 1.1. 사용법
``` c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *file_name, struct stat *buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *file_name, struct stat *buf);
```
각 함수들의 호출 성공시 0을 반환하며 두번째 인자인 stat 구조체에 파일 정보들로 채워진다.
실패 혹은 에러시 -1을 리턴하고 에러시에 errno 변수에 에러 상태가 set된다.
stat과 lstat함수는 첫번째 인자로, 절대경로를 넘겨 주어야 하고, 두번째 인자로 stat구조체 주소를 넘겨 주어야 한다.
lstat함수는 path가 심볼릭 링크 파일 경우, 심볼릭 링크 파일에 대한 정보를 구조제에 채운다. (stat 함수는  원본의 정보를 채운다.)

## 1.2. 설명
stat() 함수를 이용하면 파일의 상태를 알아올수 있다. 첫번째 인자로 주어진 file_name 의 상태를 얻어와서 두번째 인자인 buf 에 채워 넣는다.
lstat() 함수는 심볼릭:::링크(:12)파일의 원본파일의 상태를 얻어온다는 것을 제외하고는 stat() 함수와 동일하다.
fstat() 는 open(2) 등을 통해서 만들어진 파일지시자를 인자로 받아들인다는 점 외에는 stat() 와 동일한 일을 수행한다
``` c
struct stat {
    dev_t         st_dev;      /* device */
    ino_t         st_ino;      /* inode */
    mode_t        st_mode;     /* protection */
    nlink_t       st_nlink;    /* number of hard links */
    uid_t         st_uid;      /* user ID of owner */
    gid_t         st_gid;      /* group ID of owner */
    dev_t         st_rdev;     /* device type (if inode device) */
    off_t         st_size;     /* total size, in bytes */
    blksize_t     st_blksize;  /* blocksize for filesystem I/O */
    blkcnt_t      st_blocks;   /* number of blocks allocated */
    time_t        st_atime;    /* time of last access */
    time_t        st_mtime;    /* time of last modification */
    time_t        st_ctime;    /* time of last change */
};
```
## 1.3 example code
``` c
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <pwd.h>
#include <grp.h>

int main(int argc, char **argv)
{
    int return_stat;
    char *file_name;
    struct stat file_info;
    struct passwd *my_passwd;
    struct group  *my_group;
    mode_t file_mode;
    
    if (argc != 2 ) {
        printf("Usage : ./file_info [file name]\n");
        exit(0);
    }
    file_name = argv[1];    

    if ((return_stat = stat(file_name, &file_info)) == -1) {
        perror("Error : ");
        exit(0);
    }

    file_mode = file_info.st_mode;
    printf("파일이름 : %s\n", file_name);
    printf("=======================================\n");
    printf("파일 타입 : ");
    if (S_ISREG(file_mode)) {
        printf("정규파일\n");
    } else if (S_ISLNK(file_mode)) {
        printf("심볼릭 링크\n");
    } else if (S_ISDIR(file_mode)) {
        printf("디렉토리\n");    
    } else if (S_ISCHR(file_mode)) {
        printf("문자 디바이스\n");
    } else if (S_ISBLK(file_mode)) {
        printf("블럭 디바이스\n");
    } else if (S_ISFIFO(file_mode)) {
        printf("FIFO\n");
    } else if (S_ISSOCK(file_mode)) {
        printf("소켓\n");
    }

    my_passwd = getpwuid(file_info.st_uid);
    my_group  = getgrgid(file_info.st_gid);
    printf("OWNER : %s\n", my_passwd->pw_name);
    printf("GROUP : %s\n", my_group->gr_name);
    printf("FILE SIZE IS : %d\n", file_info.st_size);
    printf("마지막 읽은 시간 : %d\n", file_info.st_atime);
    printf("마지막 수정 시간 : %d\n", file_info.st_mtime);
    printf("하드링크된 파일수 : %d\n", file_info.st_nlink);
}
```
## 1.4. 참조 링크
https://bodamnury.tistory.com/37
https://linux.die.net/man/2/stat

# Linux C - inotify
## inotify란
- 파일 시스템 이벤트 모니터링 모듈 
- Linux 2.6.13 커널부터 Inotify가 포함
- 모니터링 프로그램에서 하나의 파일 디스크립터를 열어서 하나 이상의 파일이나 디렉토리에서 열기, 닫기, 이동/이름 변경, 삭제, 작성이나 속성 변경과 같은 지정된 이벤트가 발생하는지 감시할 수 있다.
## inotify API
### 1. inotify_init
이 함수는 inotify 인스턴스를 작성하고 이 인스턴스가 참조하는 파일 디스크립터를 리턴하는 시스템 호출이다.
커널 에 inotify 하위 시스템의 인스턴스를 만들고 성공하면 파일 디스크립터를 리턴
실패하면 -1 리턴 
다른 시스템 호출과 마찬가지로 실패하면 errno 확인 필요.

### 2. inotify_init1
이 함수는 inotify_init와 비슷하지만 추가 플래그가 있다. 플래그가 지정되지 않으면 이 함수는 inotify_init와 동일하게 작동한다.

### 3. inotify_add_watch
이 함수는 파일이나 디렉토리에 감시를 추가하며 감시할 이벤트를 지정한다. 
기존 감시에 이벤트를 추가해야 하는지, 경로에 디렉토리가 표시되는 경우에만 감시를 수행해야 하는지, 
기호 링크를 수행해야 하는지 그리고 감시가 첫 번째 이벤트가 발생하면 중지되어야 하는 일회성 감시인지를 플래그를 통해 제어한다.
성공 하면 inotify_add_watch()호출은 등록된 시계의 고유 식별자를 반환합니다. 
실패하면 -1을 반환합니다. 식별자를 사용하여 연결된 시계를 변경하거나 제거 가능합니다.

### 4. inotify_rm_watch
이 함수는 감시 목록에서 감시 항목을 제거한다.

### 5. read
이 함수는 하나 이상의 이벤트에 관한 정보가 포함된 버퍼를 읽는다.

### 6. close
이 함수는 파일 디스크립터를 닫고 파일 디스크립터에 남아 있는 모든 감시를 제거한다. 
인스턴스의 모든 파일 디스크립터가 닫히면 해당 자원과 기본 오브젝트가 해제되며 따라서 커널에서 이러한 자원과 오브젝트를 다시 사용할 수 있게 된다.

## 일반적인 모니터링 과정
1.`inotify_init`를 사용하여 파일 디스크립터를 연다.
2.하나 이상의 감시를 추가한다.(`inotify_add_watch`)
3.이벤트를 대기한다.(`read`)
4.이벤트를 처리한 후 대기 상태로 돌아간다.
5.더 이상 활성화된 감시가 없거나 어떤 신호를 수신하는 경우에는 파일 디스크립터를 닫고 정리한 후 종료된다.(`close`)

## inotify_event
``` C
struct inotify_event
{
    int wd; /* Watch descriptor. */
    uint32_t mask; /* Watch mask. */
    uint32_t cookie; /* Cookie to synchronize two events. */
    uint32_t len; /* Length (including NULs) of name. */
    char name __flexarr; /* Name. */
};
```
- name: 필드는 감시 항목이 디렉토리이고, 이벤트가 디렉토리에 있는 항목에 해당하는 경우에만 표시
- cookie: IN_MOVED_FROM 이벤트와 IN_MOVED_TO 이벤트가 감시할 항목과 관련된 경우에는 두 이벤트의 연관성을 확인하기 위해 쿠키를 사용
- mask: 커널에 의해 설정되는 플래그와 함께 이벤트 유형이 리턴. 예를 들면, 이벤트 대상이 디렉토리인 경우에는 커널에서 IN_ISDIR 플래그를 설정.
## event 종류
여러 이벤트를 감시할 수 있다. IN_DELETE_SELF와 같은 것은 감시할 항목에만 적용하는 데 반해서 IN_ATTRIB나 IN_OPEN과 같은 것은 감시 항목이나 해당 항목이 디렉토리인 경우에는 디렉토리 안에 있는 디렉토리나 파일에 적용할 수 있다.
### IN_ACCESS
감시 디렉토리에 있는 감시 항목이 액세스되었다. 예를 들면, 열린 파일이 읽힌 경우
### IN_MODIFY
감시 디렉토리에 있는 감시 항목이 수정되었다. 예를 들면, 열린 파일이 업데이트된 경우
### IN_ATTRIB
감시 디렉토리에 있는 감시 항목에서 메타데이터가 변경되었다. 예를 들면, 시간소인이나 사용 권한이 변경된 경우
### IN_CLOSE_WRITE
쓰기 위해 연 파일이나 디렉토리가 닫혔다.
### IN_CLOSE_NOWRITE
읽기 전용으로 연 파일이나 디렉토리가 닫혔다.
### IN_CLOSE
이전의 두 가지 닫기 이벤트(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)를 논리적 OR 연산을 하는 편리한 마스크이다.
### IN_OPEN
파일이나 디렉토리가 열렸다.
### IN_MOVED_FROM
감시 디렉토리에 있는 감시 항목이 감시 위치에서 이동되었다. 또한, 이 이벤트에는 쿠키가 포함되어 있으며 사용자는 이 쿠키를 이용하여 IN_MOVED_FROM와 IN_MOVED_TO의 연관성을 확인할 수 있다.
### IN_MOVED_TO
파일이나 디렉토리가 감시 위치에서 이동되었다. 이 이벤트에는 IN_MOVED_FROM과의 연관성을 확인할 수 있는 쿠키가 포함되어 있다. 파일이나 디렉토리의 이름이 변경되면 두 가지 이벤트가 모두 표시된다. 파일이나 디렉토리가 감시하고 있지 않은 위치로 이동하거나 이 위치에서 이동되는 경우에는 한 가지 이벤트만 표시된다. 사용자가 감시 항목을 이동하거나 이름을 변경하는 경우에도 감시는 계속된다. 아래에 있는 IN_MOVE-SELF를 살펴보자.
### IN_MOVE
이전의 두 가지 이동 이벤트(IN_MOVED_FROM | IN_MOVED_TO)를 논리적 OR 연산을 하는 편리한 마스크이다.
### IN_CREATE
서브디렉토리나 파일이 감시 디렉토리에서 작성되었다.
### IN_DELETE
서브디렉토리나 파일이 감시 디렉토리에서 삭제되었다.
### IN_DELETE_SELF
감시 항목 자체가 삭제되었다. 감시가 종료되고 IN_IGNORED 이벤트를 수신하게 된다.
### IN_MOVE_SELF
감시 항목 자체가 이동되었다.
### 기타
이벤트 플래그 외에도 사용자가 Inotify 헤더(/usr/include/sys/inotify.h)에서 찾을 수 있는 몇 가지 다른 플래그가 있다. 예를 들어, 첫 번째 이벤트만 감시하려고 하는 경우에는 감시를 추가할 때 IN_ONESHOT 플래그를 설정한다.
## example 코드
``` c
void signal_handler (int signum)
{
    keep_running = 0;
}

int main (int argc, char **argv)
{
    int inotify_fd;

    keep_running = 1;

    if (signal (SIGINT, signal_handler) == SIG_IGN) {
        signal (SIGINT, SIG_IGN);
    }

    inotify_fd = open_inotify_fd (); 
    if (inotify_fd > 0) {
        int wd; 
        int index;
        queue_t q;

        q = queue_create (128);

        wd = 0;
        printf("\n");
        for (index = 1; (index < argc) && (wd >= 0); index++) {
            wd = watch_dir (inotify_fd, argv[index], IN_ALL_EVENTS);
        }

        if (wd > 0) {
            process_inotify_events (q, inotify_fd);
        }
        printf ("\nTerminating\n");

        close_inotify_fd (inotify_fd);
        queue_destroy (q);
    }
    return 0;
}
```
## inotifywait
리눅스에서 지원하는 inotifywait 커맨드를 이용하는 방법도 있다.
ex)
터미널 1
``` bash
# touch cheese
# while inotifywait -e modify cheese; do 
>   echo someone touched my cheese
> done
```
터미널 2
``` bash
echo lol >> cheese
```
결과
``` bash
Setting up watches.
Watches established.
cheese MODIFY 
someone touched my cheese
Setting up watches.
Watches established.
```
# C - Poll
poll은 select 와 마찬가지로 다중입출력 을 구현하기 위한 방법으로 사용되며, 동시에 여러개의 클라이언트를 다루는 서버를 제작하기 위한 방법으로 흔히 사용된다.
select 의 경우 입출력 이벤트가 발생했을 때 넘겨주는 정보가 너무 적음으로써, 프로그래밍시 여기에 신경을 써줘야 하는데 poll 을 이용하면 이러한 제한을 극복할수 있다.
## poll
``` C
int poll(struct poolfd *ufds, unsigned int nfds, int timeout);
```
poll이 여러개의 파일을 다루는 방법은 select 와 마찬가지로 파일지시자의 이벤트를 기다리다가 이벤트가 발생하면, poll 에서의 block 이 해제되고, 다음 루틴에서 어떤 파일지시자에 이벤트가 발생했는지 검사하는 방식을 사용하게 된다.
## pollfd
``` C
struct pollfd
{
	int fd;         // 관심있어하는 파일지시자
	short events;   // 발생된 이벤트
	short revents;  // 돌려받은 이벤트
};
```
fd - 파일 디스크립터
events - 파일 디스크립터가 발생시키는 이벤트
revents - 커널에서 이 events 에 어떻게 반응 했는지에 대한 반응 값이다.
## events
`<sys/poll.h>` 에 디파인 되어 있다.
``` c
    #define POLLIN      0x0001  // 읽을 데이타가 있다.
    #define POLLPRI     0x0002  // 긴급한 읽을 데이타가 있다.
    #define POLLOUT     0x0004  // 쓰기가 봉쇄(block)가 아니다. 
    #define POLLERR     0x0008  // 에러발생
    #define POLLHUP     0x0010  // 연결이 끊겼음
    #define POLLNVAL    0x0020  // 파일지시자가 열리지 않은것같은 Invalid request (잘못된 요청)
```
## nfds
- pollfd 의 배열의 크기
- 우리가 조사할 파일지시자의 크기(네트웍프로그래밍측면에서 보자면 받아들일수 있는 클라이언트의 크기)
- 보통 프로그래밍 할때 그 크기를 지정해준다.
## timeout
- select 의 time 와 같은 역할
- 값을 지정하지 않을경우 이벤트가 발생하기 전까지 영원히 기다린다.
- 0일 경우는 기다리지 않고 곧바로 다음 루틴을 진행
- 0보다 큰 양의 정수일 경우에는 해당 시간만큼을 기다리게 된다. 
- 해당 시간내에 어떤 이벤트가 발생하면 즉시 되돌려 주며, 시간을 초과하게 될 경우 0을 return 한다.
## example
``` c
#include <sys/time.h> 
#include <sys/socket.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <unistd.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <string.h> 
#include <netinet/in.h> 
#include <arpa/inet.h> 
#include <sys/poll.h> 

// 받아들일수 있는 클라이언트의 크기
#define OPEN_MAX    600 

int main(int argc, char **argv)
{

    int server_sockfd, client_sockfd, sockfd;

    int i, maxi;
    int nread;
    int state = 0;

    socklen_t clilen;

    struct sockaddr_in clientaddr, serveraddr;

    char buf[255];
    char line[255];

    FILE *fp;

    struct pollfd client[OPEN_MAX];

    if (argc != 2)
    {
        printf("Usage : ./zipcode_poll [port]\n");
        printf("예    : ./zipcode_poll 4444\n");
        exit(0);
    }


    if ((fp = fopen("zipcode.txt", "r")) == NULL)
    {
        perror("file open error : ");
        exit(0);
    }

    if ((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        perror("socket error : ");
        exit(0);
    }
    bzero(&serveraddr, sizeof(serveraddr));
    serveraddr.sin_family = AF_INET;
    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
    serveraddr.sin_port = htons(atoi(argv[1]));

    state = bind(server_sockfd, (struct sockaddr *)&serveraddr, 
                sizeof(serveraddr));

    if (state == -1)
    {
        perror("bind error : ");
        exit(0);
    }
    state = listen(server_sockfd, 5);
    if (state == -1)
    {
        perror("listen error : ");
        exit(0);
    }

    // pollfd  구조체에 
    // 소켓지시자를 할당한다.  
    // 소켓에 쓰기 events (POLLIN)에 대해서 
    // 반응하도록 세팅한다. 
    client[0].fd = server_sockfd;
    client[0].events = POLLIN;

    // pollfd 구조체의 모든 fd 를 -1 로 초기화 한다.  
    // fd 가 -1 이면 파일지시자가 세팅되어있지 않다는 뜻이다. 
    for (i = 1; i < OPEN_MAX; i++)
    {
        client[i].fd = -1;
    }
    maxi = 0;

    // POLLING 시작
    for (;;)
    {
        nread = poll(client, maxi + i, 1000);

        // 만약 POLLIN 이벤트에 대해서 
        // 되돌려준 이벤트가(revents) POLLIN
        // 이라면 accept 한다. 
        if (client[0].revents & POLLIN)
        {
            clilen=sizeof(clientaddr);
            client_sockfd = accept(server_sockfd, 
                            (struct sockaddr *)&clientaddr, 
                            &clilen);
            for (i = 1; i < OPEN_MAX; i++)
            {
                if (client[i].fd < 0)
                {
                    client[i].fd = client_sockfd;
                    break;
                }
            }

            if (i == OPEN_MAX)
            {
                perror("too many clients : ");
                exit(0);
            }

            client[i].events = POLLIN;

            if (i > maxi)
            {
                maxi = i;
            }

            if (--nread <= 0)
                continue;
        }

        // 현재 파일지시자의 총갯수 만큼 루프를 돌면서 
        // 각 파일지시자에 POLLIN revent 가 발생했는지를 조사하고 
        // POLLIN이 발생했다면, 해당 파일지시자에서 데이타를 읽어들이고, 
        // 주소정보를 돌려준다. 
        // 만약 "quit" 를 읽었다면, 소켓연결을 끊는다. 
        for (i = 1; i <= maxi; i++)
        {
            if ((sockfd = client[i].fd) < 0)
                continue;
            if (client[i].revents & (POLLIN | POLLERR))
            {
                rewind(fp);
                memset(buf, 0x00, 255);
                if (read(sockfd, buf, 255) <= 0)
                {
                    close(client[i].fd);
                    client[i].fd = -1;
                }
                else
                {
                    if (strncmp(buf, "quit", 4) == 0)
                    {
                        write(sockfd, "byebye\n", 7);
                        close(client[i].fd);
                        client[i].fd = -1;
                        break;
                    }
                    while(fgets(line, 255, fp) != NULL)
                    {
                        if (strstr(line, buf) != NULL)
                            write(sockfd, line, 255);
                        memset(line, 0x00, 255);
                    }
                }
            }
        }
    }
}
```
# C - 파일 변화 감지
# 1. 계속 읽기
ex)
``` c
#include <stdio.h>

int main () {
    FILE *fp;
    char str[512];

    /* opening file for reading */
    fp = fopen("/var/log/secure" , "r");
    if(fp == NULL) {
        perror("Error opening file");
        return(-1);
    }   

    fseek(fp, -3, SEEK_END);
    while(1) {
        if( fgets (str, 256, fp)!=NULL ) { 
            printf("str: %s\n", str);
        }
        sleep(1);
    }   
    fclose(fp);

    return(0);
}
```
## 2. modify 될 때마다 읽기
ex)
``` c
#include <sys/inotify.h>
#include <unistd.h>
#include <stdio.h>

#define EVENT_SIZE  (sizeof (struct inotify_event))
#define BUF_LEN        (16 * (EVENT_SIZE + 16))

int main()
{
    int fd; 
    fd = inotify_init();
    if (fd < 0)
        perror("inotify_init()");

    int wd; 
    wd = inotify_add_watch(fd, "/var/log/", IN_MODIFY);
    if (wd < 0)
        perror("inotify_add_watch");

    char buf[BUF_LEN];
    int len;

start:
    len = read(fd, buf, BUF_LEN);
    if (len > 0)
    {   
        int i = 0;
        while (i < len) {
            struct inotify_event *event;
            event = (struct inotify_event *) &buf[i];

            printf("wd=%d mask=%x cookie=%u len=%u\n",
                    event->wd, event->mask,
                    event->cookie, event->len);

            if (event->mask & IN_MODIFY)
                printf("file modified %s", event->name);

            if (event->len)
                printf("name=%s\n", event->name);

            i += EVENT_SIZE + event->len;
        }   
    }   

    goto start;

    return 0;
}
```
## 3. delete 감지하고 delete 되면 파일 reopen
``` c
#include <sys/inotify.h>
#include <unistd.h>
#include <stdio.h>

#define LOG_DIR_PATH "/var/log/"
#define LOG_FILE_NAME "secure"
#define LOG_FILE_PATH LOG_DIR_PATH LOG_FILE_NAME

#define SSH_LOG_GUARD_TIME 180

static pthread_mutex_t g_ssh_log_lock;

struct ssh_log
{
    int in_use;
    char month[4];
    char day[3];
    char time[10];
    char shost[10];
    char ip[16];
    char user[30];
    int pflag;
    int iflag;
    int direction;
    time_t extime;
};

enum {
    DV_SSHLOG_LOGIN = 1,
    DV_SSHLOG_LOGOUT
};

#define MAX_LOG_NUM 30
struct ssh_log g_ssh_log[MAX_LOG_NUM];

int dv_ssh_log_print(struct ssh_log* inlog)
{
    if(!inlog)
        return -1; 
            
    if(inlog->direction == DV_SSHLOG_LOGIN) {
        printf("ID %s SSH login successfully from %s\n", inlog->user, inlog->ip); 
    } else if(inlog->direction == DV_SSHLOG_LOGOUT) {
        printf("ID %s SSH logout successfully from %s\n",  inlog->user, inlog->ip); 
    }   

    return 0;
}

int dv_ssh_log_update(struct ssh_log* inlog)
{
    int i;
    int empty_num = -1; 
    time_t cur_time = time(NULL);

    if(!inlog)
        return -1; 

    pthread_mutex_lock(&g_ssh_log_lock);
    for(i=0; i<MAX_LOG_NUM; i++) {
        if(cur_time > SSH_LOG_GUARD_TIME + g_ssh_log[i].extime) {
            memset(&g_ssh_log[i], 0x00, sizeof(struct ssh_log));
        }

        if((empty_num == -1) && g_ssh_log[i].in_use == 0) {
            empty_num = i;
        }

        if(!strncmp(g_ssh_log[i].month, inlog->month, sizeof(inlog->month)) && !strncmp(g_ssh_log[i].day, inlog->day, sizeof(inlog->day)) && \
            !strncmp(g_ssh_log[i].time, inlog->time, sizeof(inlog->time)) && !strncmp(g_ssh_log[i].shost, inlog->shost, sizeof(inlog->shost))) {
            if(inlog->pflag) {
                g_ssh_log[i].pflag = 1;
                memcpy(g_ssh_log[i].user, inlog->user, sizeof(inlog->user));
            } else {
                g_ssh_log[i].iflag = 1;
                memcpy(g_ssh_log[i].ip, inlog->ip, sizeof(inlog->ip));
            }
            dv_ssh_log_print(&g_ssh_log[i]);
            memset(&g_ssh_log[i], 0x00, sizeof(struct ssh_log));
            pthread_mutex_unlock(&g_ssh_log_lock);
            return 0;
        }
    }

    if(empty_num >=0) {
        memcpy(&g_ssh_log[empty_num], inlog, sizeof(struct ssh_log));
        g_ssh_log[empty_num].extime = cur_time;
    }
    pthread_mutex_unlock(&g_ssh_log_lock);

    return 0;
}

int strtok_test(char* buf)
{
    int i = 0;
    char *chunk;
    int sshflag = 0;
    int pflag = 0;
    int aflag = 0;
    int dflag = 0;
    struct ssh_log test;

    if(!buf)
        return -1;

    memset(&test, 0x00, sizeof(test));
    buf[strlen(buf) - 1] = '\0';
    while((chunk = strsep(&buf, " ")) != NULL) {
        if(chunk) {
            if(i == 0) {
                snprintf(test.month, sizeof(test.month), "%s", chunk);
            } else if(i == 1) {
                snprintf(test.day, sizeof(test.day), "%s", chunk);
            } else if(i == 2) {
                snprintf(test.time, sizeof(test.time), "%s", chunk);
            } else if(i == 3) {
                snprintf(test.shost, sizeof(test.shost), "%s", chunk);
            } else if(i == 4) {
                if(strncmp("sshd", chunk, 4)) {
                    return -1;
                } else {
                    sshflag = 1;
                }
            } else if(i == 5) {
                if(strlen(chunk) >= strlen("pam_unix") && !strncmp(chunk, "pam_unix", 8)) {
                    pflag = 1;
                    test.pflag = 1;
                } else if(strlen(chunk) >= strlen("Accepted") && !strncmp(chunk, "Accepted", 8)) {
                    aflag = 1;
                    test.iflag = 1;
                }
            } else if(i == 6) {
                if(!pflag && !aflag) {
                    if(strlen(chunk) >= strlen("disconnect") && !strncmp(chunk, "disconnect", 10)) {
                        dflag = 1;
                        test.iflag = 1;
                    }
                }
            } else if(i == 6) {
                if(pflag) {
                    if(strlen(chunk) >= strlen("closed") && !strncmp(chunk, "closed", 6)) {
                        aflag = 1;
                        test.direction = DV_SSHLOG_LOGOUT;
                    } else if(strlen(chunk) >= strlen("opened") && !strncmp(chunk, "opened", 6)) {
                        dflag = 1;
                        test.direction = DV_SSHLOG_LOGIN;
                    }
                }
            } else if(i == 8) {
                if(!pflag && dflag) {
                    test.direction = DV_SSHLOG_LOGOUT;
                    snprintf(test.ip, sizeof(test.ip), "%s", chunk);
                }
            } else if(i == 10) {
                if(pflag) {
                    snprintf(test.user, sizeof(test.user), "%s", chunk);
                } else if(aflag) {
                    test.direction = DV_SSHLOG_LOGIN;
                    snprintf(test.ip, sizeof(test.ip), "%s", chunk);
                }
            }
        }
        i++;
    }

    if(sshflag) {
        test.in_use = 1;
        dv_ssh_log_update(&test);
    }

    return 0;
}

int dv_logfile_open(FILE** fp, int flag)
{
    if(!fp)
        return -1;

    *fp = fopen(LOG_FILE_PATH, "r");
    if(!*fp) {
        perror("Error opening file");
        return(-1);
    }

    if(flag)
        dv_logfile_read(fp);

    fseek(*fp, -3, SEEK_END);

    return(0);
}

int dv_logfile_read(FILE** fp)
{
    char str[512];

    if(!fp)
        return -1;

    while(fgets (str, 256, *fp)!=NULL) {
        strtok_test(str);
    }
    return 0;
}

int dv_logfile_close(FILE** fp)
{
    if(!*fp)
        return -1;

    fclose(*fp);
    *fp = NULL;
    return 0;
}

int main(void)
{
    int length, i = 0;
    int fd;
    int wd;
    char buffer[EVENT_BUF_LEN];
    FILE* log_fd = NULL;

    pthread_mutex_init(&g_ssh_log_lock, NULL);

    fd = inotify_init();
    if ( fd < 0 ) {
        return -1;
    }

    dv_logfile_open(&log_fd, 0);

    wd = inotify_add_watch(fd, LOG_DIR_PATH, IN_CREATE | IN_DELETE | IN_MODIFY);
    while(1) {
        length = read( fd, buffer, EVENT_BUF_LEN );
        if(length > 0) {
            i = 0;
            while ( i < length ) {
                struct inotify_event *event;
                event = ( struct inotify_event * ) &buffer[ i ];
                if ( event->len ) {
                    if ( event->mask & IN_CREATE ) {
                        if(!strncmp(LOG_FILE_NAME, event->name, strlen(LOG_FILE_NAME))) {
                            if(log_fd)
                                dv_logfile_close(&log_fd);

                            dv_logfile_open(&log_fd, 1);
                        }
                    } else if ( event->mask & IN_DELETE ) {
                        if(!strncmp(LOG_FILE_NAME, event->name, strlen(LOG_FILE_NAME))) {
                            if(log_fd)
                                dv_logfile_close(&log_fd);
                        }
                    } else if ( event->mask & IN_MODIFY) {
                        if(!strncmp(LOG_FILE_NAME, event->name, strlen(LOG_FILE_NAME))) {
                            if(!log_fd) {
                                dv_logfile_open(&log_fd, 0);
                            }
                            if(log_fd) {
                                dv_logfile_read(&log_fd);
                            }
                        }
                    }
                    i += EVENT_SIZE + event->len;
                }
            }
        }
    }

    inotify_rm_watch( fd, wd );
    close( fd );

    return 0;
}
```
# Linux C - Netlink API
netlink - 커널과 사용자 공간 간의 통신(AF_NETLINK)
## 개요 
``` c
#include < asm/types.h >
#include < sys/socket.h >
#include < linux/netlink.h >

netlink_socket = socket(AF_NETLINK,  socket_type ,  netlink_family );
```
## 설명
Netlink는 커널과 사용자 공간 프로세스 간에 정보를 전송하는 데 사용
사용자 공간 프로세스를 위한 표준 소켓 기반 인터페이스와 커널 모듈을 위한 내부 커널 API로 구성 
Netlink는 데이터그램 지향 서비스
SOCK_RAW 및 SOCK_DGRAM 모두 socket_type 에 유효 
netlink 프로토콜은 데이터그램과 원시 소켓을 구분하지 않습니다.
netlink_family 는 통신할 커널 모듈 또는 netlink 그룹을 선택. 
## 종류
### NETLINK_ROUTE
라우팅 및 링크 업데이트를 수신하고 라우팅 테이블(IPv4 및 IPv6 모두), IP 주소, 링크 매개변수, 인접 설정, 대기열 규칙, 트래픽 클래스 및 패킷 분류자를 수정하는 데 사용
### NETLINK_W1
1-와이어 서브시스템의 메시지.
### NETLINK_USERSOCK
사용자 모드 소켓 프로토콜용으로 예약
### NETLINK_FIREWALL
netfilter에서 사용자 공간으로 IPv4 패킷을 전송합니다. ip_queue 커널 모듈에서 사용
### NETLINK_INET_DIAG
INET 소켓 모니터링.
### NETLINK_NFLOG
Netfilter/iptables ULOG.
### NETLINK_XFRM
IPsec.
### NETLINK_SELINUX
SELinux 이벤트 알림.
### NETLINK_ISCSI
개방형 iSCSI.
### NETLINK_FIB_LOOKUP
사용자 공간에서 FIB 조회에 액세스합니다.
### NETLINK_CONNECTOR
커널 커넥터. 자세한 내용 은 Linux 커널 소스 트리의 Documentation/connector/* 를 참조
### NETLINK_NETFILTER
넷필터 하위 시스템.
### NETLINK_IP6_FW
netfilter에서 사용자 공간으로 IPv6 패킷을 전송합니다. ip6_queue 커널 모듈에서 사용
### NETLINK_DNRTMSG
DECnet 라우팅 메시지.
### NETLINK_KOBJECT_UEVENT
사용자 공간에 대한 커널 메시지.
### NETLINK_GENERIC
단순화된 넷링크 사용을 위한 일반 넷링크 제품군.
## netlink 메시지
- Netlink 메시지는 하나 이상의 nlmsghdr 헤더 및 관련 페이로드가 있는 바이트 스트림으로 구성
- 바이트 스트림은 표준 NLMSG_* 매크로로만 액세스해야 합니다. 
- 멀티파트 메시지( 하나의 바이트 스트림에 연관된 페이로드가 있는 여러 nlmsghdr 헤더)에서 NLMSG_DONE 유형의 마지막 헤더를 제외하고 첫 번째 및 모든 다음 헤더에는 NLM_F_MULTI 플래그가 설정
- nlmsghdr + 페이로드 구성
``` c
struct nlmsghdr { 
    __u32 nlmsg_len; /* 헤더를 포함한 메시지의 길이. */ 
    __u16 nlmsg_type; /* 메시지 내용의 유형. */ 
    __u16 nlmsg_flags; /* 추가 플래그. */ 
    __u32 nlmsg_seq; /* 시퀀스 번호. */ 
    __u32 nlmsg_pid; /* 발신자 포트 ID. */ 
};
```
- nlmsg_type 은 표준 메시지 유형 중 하나
NLMSG_NOOP 메시지는 무시되고, NLMSG_ERROR 메시지는 오류 신호를 보내고 페이로드에는 nlmsgerr 구조가 포함되며, NLMSG_DONE 메시지는 다중 부분 메시지를 종료합니다.
``` c
struct nlmsgerr { 
    int error; /* 확인의 경우 음수 errno 또는 0 */ 
    struct nlmsghdr msg; /* 오류를 일으킨 메시지 헤더 */ 
};
```
## 설명 2
- netlink 제품군은 일반적으로 더 많은 메시지 유형을 지정합니다. 
- NLM_F_ATOMIC 에는 CAP_NET_ADMIN 기능 또는 유효 UID 0이 필요 합니다.

- nlmsg_seq 및 nlmsg_pid 는 메시지를 추적하는 데 사용됩니다. 
- nlmsg_pid 는 메시지의 출처를 보여줍니다. 
- 메시지가 netlink 소켓에서 시작된 경우 nlmsg_pid 와 프로세스의 PID 사이에는 1:1 관계가 없습니다 . 
- nlmsg_seq 및 nlmsg_pid 모두 netlink 코어에 대해 불투명합니다.

- Netlink는 신뢰할 수 있는 프로토콜이 아닙니다. 
- 메시지를 목적지 로 전달하기 위해 최선을 다 하지만 메모리 부족 상태나 기타 오류가 발생하면 메시지를 삭제할 수 있습니다. 
- 안정적인 전송을 위해 발신자는 NLM_F_ACK 플래그 를 설정하여 수신자에게 승인을 요청할 수 있습니다 . 
- 승인은 오류 필드가 0으로 설정된 NLMSG_ERROR 패킷입니다. 
- 애플리케이션은 수신된 메시지 자체에 대한 승인을 생성해야 합니다. 
- 커널 은 모든 실패한 패킷에 대해 NLMSG_ERROR 메시지 를 보내려고 시도합니다 . 
- 사용자 프로세스도 이 규칙을 따라야 합니다.
- 커널에서 사용자로의 안정적인 전송은 어떤 경우에도 불가능
- 소켓 버퍼가 가득 차면 커널은 netlink 메시지를 보낼 수 없습니다. 
- 메시지는 삭제되고 커널과 사용자 공간 프로세스는 더 이상 동일한 커널 상태 보기를 갖지 않습니다.
- 이것이 발생하는 경우( recvmsg (2) 에서 반환된 ENOBUFS 오류를 통해)를 감지하고 재동기화하는 것은 애플리케이션에 달려 있습니다.
## 주소 형식
sockaddr_nl 구조 는 사용자 공간 또는 커널에서 넷링크 클라이언트를 설명합니다. sockaddr_nl 은 유니캐스트(하나 의 피어에게만 전송됨) 또는 넷링크 멀티캐스트 그룹( nl_groups 가 0이 아님)으로 전송될 수 있습니다.
struct sockaddr_nl { 
    sa_family_t nl_family; /* AF_NETLINK */ 
    unsigned short nl_pad; /* 영. */ 
    pid_t nl_pid; /* 포트 ID. */ 
    __u32 nl_groups; /* 멀티캐스트 그룹 마스크. */ 
};
nl_pid 는 넷링크 소켓의 유니캐스트 주소입니다. 대상이 커널에 있으면 항상 0입니다. 사용자 공간 프로세스의 경우 nl_pid 는 일반적으로 대상 소켓을 소유한 프로세스의 PID입니다. 그러나 nl_pid 는 프로세스가 아닌 넷링크 소켓을 식별합니다. 프로세스가 여러 개의 넷링크 소켓을 소유하는 경우 nl_pid 는 최대 하나의 소켓에 대한 프로세스 ID와만 같을 수 있습니다. nl_pid 를 netlink 소켓 에 할당하는 방법에는 두 가지가 있습니다 . 응용 프로그램이 bind (2) 를 호출하기 전에 nl_pid 를 설정하면 nl_pid 가독특하다. 응용 프로그램이 0으로 설정하면 커널이 할당을 처리합니다. 커널은 프로세스가 여는 첫 번째 넷링크 소켓에 프로세스 ID를 할당하고 이후에 생성되는 모든 넷링크 소켓에 고유한 nl_pid 를 할당합니다.
nl_groups 는 모든 비트가 넷링크 그룹 번호를 나타내는 비트 마스크입니다. 각 넷링크 제품군에는 32개의 멀티캐스트 그룹 세트가 있습니다. 소켓에서 bind (2)가 호출되면 sockaddr_nl의 nl_groups 필드 는 수신 대기하려는 그룹의 비트 마스크로 설정되어야 합니다. 이 필드의 기본값은 멀티캐스트가 수신되지 않음을 의미하는 0입니다. 소켓은 sendmsg (2)를 호출하거나 연결 (2)을 수행 할 때 보내려는 그룹의 비트 마스크로 nl_groups 를 설정하여 멀티캐스트 그룹에 메시지를 멀티캐스트할 수 있습니다. 유효 UID가 0 또는 CAP_NET_ADMIN 인 프로세스만기능은 넷링크 멀티캐스트 그룹을 보내거나 수신할 수 있습니다. Linux 2.6.13부터 메시지를 여러 그룹에 브로드캐스트할 수 없습니다. 멀티캐스트 그룹에 대해 수신된 메시지에 대한 모든 응답은 송신 PID와 멀티캐스트 그룹으로 다시 보내져야 합니다. 일부 Linux 커널 하위 시스템은 추가로 다른 사용자가 메시지를 보내거나 받을 수 있도록 허용할 수 있습니다. Linux 3.0에서와 같이 NETLINK_KOBJECT_UEVENT , NETLINK_GENERIC , NETLINK_ROUTE 및 NETLINK_SELINUX 그룹을 사용하면 다른 사용자가 메시지를 받을 수 있습니다. 다른 사용자가 메시지를 보낼 수 있는 그룹이 없습니다.
# Linux C - netdevice API
netdevice - Linux 네트워크 장치에 대한 저수준 액세스
## 개요
``` c
#include < sys/ioctl.h >
#include < net/if.h >
```
## 설명
Linux는 네트워크 장치를 구성하기 위해 일부 표준 ioctl을 지원합니다. 
패밀리나 유형에 관계없이 모든 소켓의 파일 설명자에서 사용할 수 있습니다. 
그들은 ifreq 구조를 전달합니다:
``` c
struct ifreq {
    char ifr_name[IFNAMSIZ]; /* Interface name */
    union {
        struct sockaddr ifr_addr;
        struct sockaddr ifr_dstaddr;
        struct sockaddr ifr_broadaddr;
        struct sockaddr ifr_netmask;
        struct sockaddr ifr_hwaddr;
        short           ifr_flags;
        int             ifr_ifindex;
        int             ifr_metric;
        int             ifr_mtu;
        struct ifmap    ifr_map;
        char            ifr_slave[IFNAMSIZ];
        char            ifr_newname[IFNAMSIZ];
        char           *ifr_data;
    };
};

struct ifconf {
    int                 ifc_len; /* size of buffer */
    union {
        char           *ifc_buf; /* buffer address */
        struct ifreq   *ifc_req; /* array of structures */
    };
};
```
일반적으로 사용자는 ifr_name 을 인터페이스 이름으로 설정하여 영향을 줄 장치를 지정합니다. 구조의 다른 모든 구성원은 메모리를 공유할 수 있습니다.
## Ioctls
ioctl이 권한 있는 것으로 표시된 경우 이를 사용하려면 유효 사용자 ID 0 또는 CAP_NET_ADMIN 기능이 필요합니다. 그렇지 않은 경우 EPERM 이 반환됩니다.
### SIOCGIFNAME
ifr_ifindex 가 주어지면 ifr_name 의 인터페이스 이름을 반환합니다 . 이것은 ifr_name 에 결과를 반환하는 유일한 ioctl입니다 .
### SIOCGIFINDEX
인터페이스의 인터페이스 인덱스를 ifr_ifindex 로 검색합니다 .
### SIOCGIFFLAGS , SIOCSIFFLAGS
장치의 활성 플래그 단어를 가져오거나 설정합니다. ifr_flags 는 다음 값의 비트 마스크를 포함합니다.
활성 플래그 단어를 설정하는 것은 권한이 있는 작업이지만 모든 프로세스에서 읽을 수 있습니다.
### SIOCGIFPFLAGS , SIOCSIFPFLAGS
장치에 대한 확장(비공개) 플래그를 가져오거나 설정합니다. ifr_flags 는 다음 값의 비트 마스크를 포함합니다.
확장(개인) 인터페이스 플래그를 설정하는 것은 권한이 있는 작업입니다.
### SIOCGIFADDR , SIOCSIFADDR
ifr_addr 을 사용하여 장치의 주소를 가져오거나 설정합니다 . 인터페이스 주소 설정은 권한이 있는 작업입니다. 호환성을 위해 AF_INET 주소만 허용되거나 반환됩니다.
### SIOCGIFDSTADDR , SIOCSIFDSTADDR
ifr_dstaddr 을 사용하여 지점간 장치의 대상 주소를 가져오거나 설정합니다 . 호환성을 위해 AF_INET 주소만 허용되거나 반환됩니다. 대상 주소를 설정하는 것은 권한이 있는 작업입니다.
### SIOCGIFBRDADDR , SIOCSIFBRDADDR
ifr_brdaddr 을 사용하여 장치의 브로드캐스트 주소를 가져오거나 설정합니다 . 호환성을 위해 AF_INET 주소만 허용되거나 반환됩니다. 브로드캐스트 주소 설정은 권한이 있는 작업입니다.
### SIOCGIFNETMASK , SIOCSIFNETMASK
ifr_netmask 를 사용하여 장치의 네트워크 마스크를 가져오거나 설정합니다 . 호환성을 위해 AF_INET 주소만 허용되거나 반환됩니다. 네트워크 마스크 설정은 권한이 있는 작업입니다.
### SIOCGIFMETRIC , SIOCSIFMETRIC
ifr_metric 을 사용하여 장치의 메트릭을 가져오거나 설정합니다 . 이것은 현재 구현되지 않았습니다. 읽기를 시도하면 ifr_metric 을 0으로 설정하고 설정을 시도하면 EOPNOTSUPP를 반환 합니다 .
### SIOCGIFMTU , SIOCSIFMTU
ifr_mtu 를 사용하여 장치의 MTU(최대 전송 단위)를 가져오거나 설정합니다 . MTU 설정은 권한이 있는 작업입니다. MTU를 너무 작은 값으로 설정하면 커널 충돌이 발생할 수 있습니다.
### SIOCGIFHWADDR , SIOCSIFHWADDR
ifr_hwaddr 을 사용하여 장치의 하드웨어 주소를 가져오거나 설정합니다 . 하드웨어 주소는 struct sockaddr 에 지정됩니다 . sa_family 는 ARPHRD_* 장치 유형을 포함하고 sa_data 는 바이트 0부터 시작하는 L2 하드웨어 주소를 포함합니다. 하드웨어 주소 설정은 권한이 있는 작업입니다.
### SIOCSIFHWBROADCAST
ifr_hwaddr 에서 장치의 하드웨어 브로드캐스트 주소를 설정합니다 . 이것은 권한이 있는 작업입니다.
### SIOCGIFMAP , SIOCSIFMAP
ifr_map 을 사용하여 인터페이스의 하드웨어 매개변수를 가져오거나 설정합니다 . 매개변수 설정은 권한이 있는 작업입니다.
``` c
struct ifmap {
    unsigned long   mem_start;
    unsigned long   mem_end;
    unsigned short  base_addr;
    unsigned char   irq;
    unsigned char   dma;
    unsigned char   port;
};
```
ifmap 구조의 해석은 장치 드라이버와 아키텍처에 따라 다릅니다.
### SIOCADDMULTI , SIOCDELMULTI
ifr_hwaddr 을 사용하여 장치의 링크 레이어 멀티캐스트 필터에 주소를 추가하거나 삭제합니다 . 권한 있는 작업입니다. 대안은 패킷 (7)을 참조하십시오 .
### SIOCGIFTXQLEN , SIOCSIFTXQLEN
ifr_qlen 을 사용하여 장치의 전송 큐 길이를 가져오거나 설정합니다 . 전송 큐 길이 설정은 권한이 있는 작업입니다.
### SIOCSIFNAME
ifr_name에 지정된 인터페이스의 이름을 ifr_newname 으로 변경 합니다. 이것은 권한이 있는 작업입니다. 인터페이스가 작동하지 않을 때만 허용됩니다.
### SIOCGIFCONF
인터페이스(전송 계층) 주소 목록을 반환합니다. 이것은 현재 호환성을 위해 AF_INET (IPv4) 제품군의 주소만 의미합니다. 사용자는 ifconf 구조를 ioctl에 대한 인수로 전달합니다. 여기에는 ifc_req 의 ifreq 구조 배열에 대한 포인터 와 ifc_len 의 바이트 단위 길이가 포함됩니다 . 커널은 실행 중인 모든 현재 L3 인터페이스 주소로 ifreq를 채웁니다. ifr_name 은 인터페이스 이름(eth0:1 등)을 포함하고 ifr_addr 은 주소를 포함합니다. 커널은 ifc_len 의 실제 길이와 함께 반환됩니다 . ifc_len인 경우버퍼가 오버플로했을 가능성이 있는 원래 길이와 같으므로 모든 주소를 가져오려면 더 큰 버퍼로 다시 시도해야 합니다. 오류가 발생하지 않으면 ioctl은 0을 반환합니다. 그렇지 않으면 -1. 오버플로는 오류가 아닙니다.
### 기타
대부분의 프로토콜은 프로토콜별 인터페이스 옵션을 구성하기 위해 자체 ioctl을 지원합니다. 설명은 프로토콜 매뉴얼 페이지를 참조하십시오. IP 주소 구성은 ip (7)을 참조하십시오.
또한 일부 장치는 개인 ioctl을 지원합니다. 여기에 대해서는 설명하지 않습니다.
## 메모
엄밀히 말하면 SIOCGIFCONF 및 AF_INET 소켓 주소 만 수락하거나 반환하는 다른 ioctl 은 IP에 고유하며 ip (7)에 속합니다.
주소가 없거나 IFF_RUNNING 플래그가 설정 되지 않은 인터페이스의 이름은 /proc/net/dev 를 통해 찾을 수 있습니다 .
로컬 IPv6 IP 주소는 /proc/net 또는 rtnetlink (7)를 통해 찾을 수 있습니다.

# netlink & netdeivce example code
``` c
extern dvpthread_t dvapc_tinfo;         /* APC-692 */

// S1ENTWIFI-584
struct iface_status {
    char iface[6];
    int last_status;
    int cur_status;
    int reserved_down;
    struct timeval time;
};

enum {
    IFSTATUS_ERR = -1,
    IFSTATUS_DOWN = 0,
    IFSTATUS_UP = 1,
};

static int get_iface_idx_from_iface(char* iface)
{
    int i;

    if(!iface) 
        return -1;

    for(i=0; i<MAX_IFACE_STATUS; i++) {
        if(strlen(iface) == strlen(g_st[i].iface) && !strncmp(g_st[i].iface, iface, strlen(g_st[i].iface))) {
            return i;
        }
    }
    
    return -1;
}
static int get_link_status(int idx)
{
    int s;
    int r; 
    struct ifreq ifr;

    s = socket(PF_INET, SOCK_STREAM, 0);
    if(s<0) {  
        return IFSTATUS_ERR;
    }

    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, g_st[idx].iface, IFNAMSIZ);

    r = ioctl(s, SIOCGIFFLAGS, &ifr);
    if(r<0) { 
        close(s);
        return IFSTATUS_ERR;
    }

    close(s);

    if (!(ifr.ifr_flags & IFF_UP) && g_st[idx].last_status != IFSTATUS_ERR)
        return g_st[idx].last_status;

    return (ifr.ifr_flags & IFF_RUNNING) ? IFSTATUS_UP : IFSTATUS_DOWN;
}

static void send_linkup_alarm(int idx)
{
    char alarmbuf[256];

    memset(alarmbuf, 0x00, sizeof(alarmbuf));
    snprintf(alarmbuf, sizeof(alarmbuf), "APC Interface %s Link Up", g_st[idx].iface);
    davo_alarm(ALARM_APC_WAN_LINK_UP, -1, NULL, -1, NULL, -1, -1,  NULL, NULL, alarmbuf);
}

static void send_linkdown_alarm_delayed(int idx)
{
    char alarmbuf[256];

    memset(alarmbuf, 0x00, sizeof(alarmbuf));
    snprintf(alarmbuf, sizeof(alarmbuf), "APC Interface %s Link Down", g_st[idx].iface); 
    davo_alarm_delayed(ALARM_APC_WAN_LINK_DOWN, -1, NULL, -1, NULL, -1, -1,  NULL, NULL, alarmbuf, g_st[idx].time);
}

static void init_iface_status(void)
{
    int i;

    for(i=0; i<MAX_IFACE_STATUS; i++) {
        snprintf(g_st[i].iface, sizeof(g_st[i].iface), "eth%d", i);
        g_st[i].last_status = -1;
        g_st[i].cur_status = -1;
        g_st[i].reserved_down= 0;
        g_st[i].last_status = get_link_status(i);
    }
}

static int check_all_link_status(void)
{
    int i;

    for(i=0; i<MAX_IFACE_STATUS; i++) {
        if(g_st[i].cur_status == IFSTATUS_UP)
            return 0;
    }

    return 1;
}

static void send_all_reserved_down(void)
{
    int i;

    for(i=0; i<MAX_IFACE_STATUS; i++) {
        if(g_st[i].reserved_down) {
            send_linkdown_alarm_delayed(i);
            g_st[i].reserved_down = 0;
            memset(&g_st[i].time, 0x00, sizeof(g_st[i].time));
        }
    }
}

static int read_event (int sockint)
{
    int                 idx;
    int                 status;
    char                buf[4096];
    struct iovec        iov = { buf, sizeof buf };
    struct sockaddr_nl  snl;
    struct msghdr       msg = { (void *) &snl, sizeof snl, &iov, 1, NULL, 0, 0 };
    struct nlmsghdr     *h;
    struct ifinfomsg    *ifi;

    status = recvmsg (sockint, &msg, 0);
    if (status < 0) {
        if (errno == EWOULDBLOCK || errno == EAGAIN)
            return 0;

        return status;
    }

    for (h = (struct nlmsghdr *) buf; NLMSG_OK (h, (unsigned int) status);
            h = NLMSG_NEXT (h, status)) {
        if (h->nlmsg_type == NLMSG_DONE)
            return 0;

        if (h->nlmsg_type == NLMSG_ERROR)
            return -1;

        if (h->nlmsg_type == RTM_NEWLINK) {
            char ifname[20];

            ifi = NLMSG_DATA (h);
            if_indextoname(ifi->ifi_index,ifname);

            idx = get_iface_idx_from_iface(ifname);
            if(idx < 0)
                continue;

            g_st[idx].cur_status = get_link_status(idx);
            if(g_st[idx].cur_status != g_st[idx].last_status) {
                if(g_st[idx].cur_status == IFSTATUS_DOWN) {
                    if(check_all_link_status()) {
                        g_st[idx].reserved_down = 1;
                        gettimeofday(&g_st[idx].time, NULL);
                    } else {
                        send_linkdown_alarm(idx);
                    }
                } else if(g_st[idx].cur_status == IFSTATUS_UP) {
                    sleep_task(2000);
                    send_all_reserved_down();
                    send_linkup_alarm(idx);
                } else
                    continue;

                g_st[idx].last_status = g_st[idx].cur_status;
            }
        }
    }

    return 0;
}

static void ntlink_status_task(void *arg)       // APC-158
{
    int                 retval;
    int                 nl_socket;
    fd_set              rfds;
    struct timeval      tv; 
    struct sockaddr_nl  addr;

    thread_setMyTid(&dvapc_tinfo, "NTLINK_STATUS" );        /* APC-692 */

    init_iface_status();
    nl_socket = socket (AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (nl_socket < 0)
        return;

    memset ((void *) &addr, 0, sizeof (addr));
    addr.nl_family = AF_NETLINK;
    addr.nl_pid = getpid (); 
    addr.nl_groups = RTMGRP_LINK;
    if (bind (nl_socket, (struct sockaddr *) &addr, sizeof (addr)) < 0)
        return;

    gen_printf("!!! NTLINK status server started !!!\n");
    while (1) {
        FD_ZERO (&rfds);
        FD_CLR (nl_socket, &rfds);
        FD_SET (nl_socket, &rfds);

        tv.tv_sec = 10; 
        tv.tv_usec = 0;

        retval = select (FD_SETSIZE, &rfds, NULL, NULL, &tv);
        if (retval == -1)
            continue;
        else if (retval)
            read_event (nl_socket);
    }

    close(nl_socket);
}
```

### 출처
https://linux.die.net/man/7/netlink

# MTD
## MTD란
memory technology device의 약자로, char. device, block device와 같은 별도의 디바이스 그
전통적으로 OS에서 장치를 char. device 와 block device 로 나누어왔기 때문에 flash memory용 디바이스 드라이버를 둘 중 어떤 것으로 분류 시켜야 하는지 고민이 생기게 된다, MTD는 분명 hdd를 대체하는 장치로 사용되고 있지만, 그 동작 특성이 block device와는 현저히 다르기 때문에 굳이 이를 block device 로 부르는 것은 옳지 않으므로 그냥 MTD 라고 부르는 것이 맞을 것 같다. 
MTD가 선보이기 시작하였을 때 개발자들은 hdd를 대신하여 MTD를 사용하기 위해서 MTD에 기존의 파일 시스템을 올리는 방법을 궁리하였고 가장 손쉬운 방법으로 고안한 것이 FTL 이다. FTL은 Flash devcie 를 block device처럼 보이도록 변환해주는 Layer로 이를 통해서 기존의 block device용으로 개발된 파일 시스템을 변경없이 flash memroy위에서 사용할 수 있게 되었다. 하지만, FTL 을 얼마나 잘 구현했는지에 따라서 성능이나 flash device의 수명이 큰 영향을 받게 된다. 실제로 가장 손쉬운 FTL구현을 생각해 보자, 특정 data를 overwrite하기 위해서 flash는 해당 sector를 모두 지우고 새 데이터를 포함한 sector전체를 다시 write해야 한다. 단지 한바이트의 데이터를 바꾸기 위해서 매번 해당 바이트가 포함된 sector전체를 지우고 다시쓰도록 FTL을 구현한다면, 손쉬운 구현이 되겠지만 flash device의 수명(10만~100만번 erase)이 아주 짧아질 수 밖에 없을 것이다. 따라서 다양한 방법을 사용해서 모든 flash sector가 균등하게 사용되도록 FTL을 구현해야 하며, 이를 Wear Leveling이라고 부른다.

USB drive같은 몇몇 flash devices는 FTL을 아예 H/W로 구현하여 제품에 내장하여 출시하고, 이런 장치는 MTD가 아닌 block device로 보는 것이 타당하다. 그렇지 않은 Flash device에서는 FTL을 소프트웨어로 구현하게 된다.

MTD는 때로는(오히려 더 자주, 일반적으로) device차체가 아닌, device driver를 지칭하는 말로 사용된다. 이 경우에는 MTD는 FTL이 해당 Device를 control 할 수 있도록 도와주는 Low Level Driver라고 생각하면 된다. 제조사 별로, device별로 device를 제어하는 방법이 조금씩 다르기 때문에 MTD Layer에서 이를 일반화하여 주는 것이다. 따라서 FTL은 하위 device의 제조사나 특정 제품에 상관 없이 구현 될 수 있는 것이다. 아래는 FTL 을 사용하는 시스템의 구조를 표현한 것이다.

File System for block device
-----------------------------
FTL
-----------------------------
MTD Layer

최근에는 flash device를 위해서도 몇몇 파일 시스템이 개발되었으며, 이 경우 FTL이 없이 file system이 MTD Layer위에 올리기도 한다.

File System for flash device
-----------------------------
MTD Layer

하지만 필요에 따라서 flash file system이 FTL을 포함하고 있는 경우도 있으며, 이 경우의 FTL은 위에서 설명한 FTL과는 약간 다른 일을 수행하게 된다. 즉 최초의 FTL은 flash device를 block device로 변환시켜주기 위해 사용한 library 나 h/w를 의미하였으나, 최근에는 좀더 광범위한 의미로 사용되고 있다.
## 유의점
- flash를 읽을 때는 상관없지만, 쓸 때는 한 block을 다 지우고 써야 한다.
- mtd->oobblock과 같이 mtd 구조체 변수로 받는 값을 통해서 최소 쓰기 크기를 확인할 수 있다.

## example code
``` c
#include <linux/mtd/mtd.h>

#define DVFLAG_MTDNAME "0:DVFLAG"
static struct dv_mtd_flash_info
{
    struct mtd_info * mtd;
    struct erase_info ei;
};

static struct dv_mtd_flash_info dv_mtd;
static int dv_flash_open(void)
{
    dv_mtd.mtd = get_mtd_device_nm(DVFLAG_MTDNAME);

    memset(&dv_mtd.ei, 0x00, sizeof(struct erase_info));
    dv_mtd.ei.mtd  = dv_mtd.mtd;
    dv_mtd.ei.addr = 0;
    dv_mtd.ei.len  = dv_mtd.mtd->erasesize;

    return 0;
}
static int dv_flash_read(void)
{
    int retlen = 0;
    char retbuf[128];

    dv_flash_open();

    memset(retbuf, 0x00, sizeof(retbuf));
    if(!mtd_read(dv_mtd.mtd, 0, 15, &retlen, retbuf)) {
        printk(KERN_DEBUG "DAVO|JIH|0|%30s()[%04d] : -----------------------------------retbuf: %s, retlen: %d\n", __FUNCTION__, __LINE__, retbuf, retlen);
    }   
    return 0;
}

static int dv_flash_write(void)
{
    int retlen = 0;
    char buf[128];
    char retbuf[2048];

    dv_flash_open();

    memset(retbuf, 0xff, sizeof(retbuf));
    snprintf(retbuf, sizeof(retbuf), "%s", dvsock_msg);

    mtd_erase(dv_mtd.mtd, &dv_mtd.ei);
    if(!mtd_write(dv_mtd.mtd, 0, sizeof(retbuf), &retlen, retbuf)) {
        printk(KERN_DEBUG "DAVO|JIH|0|%30s()[%04d] : -----------------------------------retbuf: %x%x, retlen: %d\n", __FUNCTION__, __LINE__, retbuf[0], retbuf[1], retlen);
    } else {
        printk(KERN_DEBUG "DAVO|JIH|0|%30s()[%04d] : ----------------------------------- write error\n", __FUNCTION__, __LINE__);
    }
    return 0;
}

```
### 출처
http://dooeui.blogspot.com/2009/01/mtd.html
https://fmyson.tistory.com/337
https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=sparcman1&logNo=10093814136